'''

'''
import numpy  as np
import pandas as pd
from pathlib import Path
from ..core  import pyEPR_Analysis
from ..core  import Results_Hamiltonian

class pyEPR_Drive(pyEPR_Analysis):
    '''
    Defines an analysis object which loads data from both .npz files 
    generated by pyEPR_HFSSAnalysis and pyEPR_Analysis and 
    analyzes drive-related properties.
    '''

    def __init__(self, data_filename,
                 variations: list = None,
                 Res_hamil_filename = None):
        '''
        Args
            data_filename      : file with data generated by pyEPR_HFSSAnalysis
            variations         : variations to be analyzed
            Res_hamil_filename : file with data generated by pyEPR_Analysis ;
                                 if left None, the default filename generated
                                 by pyEPR_Analysis will be assumed.
        '''
        
        if Res_hamil_filename == None:
            data_path = Path(data_filename).resolve()
            file_name = data_path.stem
            Res_hamil_filename = str(file_name) + Results_Hamiltonian.file_name_extra
        
        super().__init__(data_filename, variations, False, Res_hamil_filename)
        
        self.modes_external_prop = []
        for i in range(self.nmodes):
            default_prop = {'label': str(i), 'kappa_nr': 0, 'T': 1e-3}
            self.modes_external_prop.append(default_prop)
            
        self.ports_external_prop = {}
        for port_name in self.project_info['ports'].axes[1]:
            default_prop = {'T': 1e-3, 'is_pump': False, 'pump_freq': 6e9, 
                            'pump_modes': [], 'pump_JJ': 0, 'beta': 0.1}
            self.ports_external_prop[port_name] = default_prop
            
        self.pumps_properties = {}
        
    def set_mode(self, idx, **kwargs):
        '''
        Set external properties of mode number 'idx'
            label    : mode name
            kappa_nr : non-radiative decay rate of the mode (MHz)
            T        : temperature of the non-radiative bath (K)
        '''
        for prop, val in kwargs.items():
            self.modes_external_prop[idx][prop] = val
        
    def set_port(self, name, **kwargs):
        '''
        Set external properties of port 'name'
            T : temperature of the transmission line photons (K)
        '''
        for prop, val in kwargs.items():
            self.ports_external_prop[name][prop] = val
            
    def set_pump(self, name='', port='', freq=6e9, modes=[], JJ=0, beta=0.1):
        '''
        Create a pump tone
            name  : pump name
            port  : port through which the circuit is pumped
            freq  : pump frequency (MHz)
            modes : list of modes involved in the pumped transition    
            JJ    : junction that is pumped
            beta  : overall amplitude of the pump ; defined such that the 
                    phase across the junction is (2 * pi * beta)
        '''
        self.pumps_properties[name] = {'port': port, 'freq': freq, 
                                       'modes': modes, 'JJ': JJ, 'beta': beta}
    
    def calc_Purcell(self, f, Q):
        '''
        Calculate the overall Purcell lifetime of each mode
        '''
        res = pd.DataFrame({})
        
        w = 2 * np.pi * f
        Qtot = 1 / (1 / Q).sum(1)
        kappa = w / Qtot
        T_purcell = 1 / kappa
        
        res['Lifetime (us)'] = T_purcell
        res['Rate (MHz)']    = kappa / (2 * np.pi)
        res.index = [p['label'] for p in self.modes_external_prop]
        
        return res
    
    def calc_MID_thermal(self, chis, fs, Q, verbose=False):
        '''
        Calculate the dephasing time of each mode due to the thermal photons
        of the transmission lines
        '''
        T_phi = pd.Series({})
    
        for i in range(self.nmodes):
            Gamma_d = 0
            for j in range(self.nmodes):
                if j == i:
                    continue
                
                f        = fs[j]
                chi      = chis.iloc[i,j]
                kappa_nr = self.modes_external_prop[j]['kappa_nr']
                kappa    = (2 * np.pi * f / Q.iloc[j]).sum() + kappa_nr
                
                for name, prop in self.ports_external_prop.items():
                    kT = 1.381e-23 * prop['T']
                    n_therm = 1 / (np.exp(6.636e-34 * f * 1e6 / kT) - 1)
                    kappa_c = 2 * np.pi * f / Q['Q_'+name][j]
                    
                    gamma_d = n_therm * kappa_c * chi**2 / (kappa**2 + chi**2)
                    Gamma_d += gamma_d
                    
                    if verbose:
                        print('Thermal MID:', name, '>', 
                              self.modes_external_prop[j]['label'], '>',
                              self.modes_external_prop[i]['label'], '=', 
                              1 / gamma_d, 'us')
             
            T_phi[self.modes_external_prop[i]['label']] = 1 / Gamma_d

        return T_phi
    
    def calc_pumped_Rabi(self, chi, Ljs):
        '''
        Calculate for each pump the induced Rabi frequency given that 
        the phase across the junction is (beta * 2 * pi).
        '''
        N = 1 # TODO: calculate the combinatory factor
        
        Omega_R = pd.Series({})
        
        for name, prop in self.pumps_properties.items():
            
            beta = prop['beta']
            Lj = Ljs[prop['JJ']] # H
            Ej = 6.636e-34 / (2*np.pi) / (2*1.602e-19)**2 / Lj * 1e-6 # rad.MHz
            
            g_eff = 2**0.75 * (2*np.pi*beta) * N
            for j in prop['modes']:
                g_eff *= chi.iloc[j,j]**0.25
            g_eff *= Ej**(0.25 * (4 - len(prop['modes'])))
            
            Omega_R[name] = g_eff / np.pi
        
        return Omega_R
    
    def calc_input_power(self, fs, Q, ZPF, phase, verbose=False):
        '''
        Calculate for each pump the input power necessary to achieve
        a phase across the junction equal to (beta * 2 * pi).
        '''
        xsi_in = pd.Series({}) # Input field
        Pin    = pd.Series({})
    
        for name, prop in self.pumps_properties.items():

            Xsi  = 0j
            beta = prop['beta']
            fp   = prop['freq']
            port = prop['port']
            
            for j in range(self.nmodes):
                
                f        = fs[j]
                zpf      = ZPF[j, prop['JJ']]
                phi      = phase['Phi_'+port][j]
                cplx_phi = np.exp(1j * phi)
                kappa_nr = self.modes_external_prop[j]['kappa_nr']
                kappa    = (2 * np.pi * f / Q.iloc[j]).sum() + kappa_nr
                kappa_c  =  2 * np.pi * f / Q['Q_'+port][j]
                delta    =  2 * np.pi * (f - fp)
                
                xsi = cplx_phi * zpf * np.sqrt(kappa_c) / (0.5 * kappa + 1j * delta)
                Xsi += xsi
                
                if verbose:
                    tmp = 2 * np.pi * beta / np.abs(xsi)
                    tmp = 6.636e-34 * fp * tmp**2 * 1e21
                    print('Pump input power:', name, '>',
                          self.modes_external_prop[j]['label'], '=', tmp, 'nW')
                
            xsi_in[name] = 2 * np.pi * beta / np.abs(Xsi) # sqrt(photons/us)
            Pin[name]    = 6.636e-34 * fp * xsi_in[name]**2 * 1e21 # nW
        
        return xsi_in, Pin
    
    def calc_MID_coherent(self, fs, chis, Q, xsi_in, verbose=False):
        '''
        For each pump, calculate the modes dephasing times induced by the  
        stationnary coherent fields built in the other modes.
        Again the pump amplitude is such that the phase across the junction 
        is equal to (beta * 2 * pi).
        '''
        labels = [p['label'] for p in self.modes_external_prop]
        T_phi = pd.DataFrame({}, index=labels)
        
        for name, prop in self.pumps_properties.items():
            
            Gamma_d = np.zeros(self.nmodes)
            fp   = prop['freq']
            port = prop['port']
            
            for i in range(self.nmodes):
                for j in range(self.nmodes):
                    if j == i:
                        continue
                    
                    f        = fs[j]
                    chi      = chis.iloc[j,i]
                    kappa_nr = self.modes_external_prop[j]['kappa_nr']
                    kappa    = (2 * np.pi * f / Q.iloc[j]).sum() + kappa_nr
                    kappa_c  =  2 * np.pi * f / Q['Q_'+port][j]
                    delta    =  2 * np.pi * (f - fp)
                    
                    n_in  = xsi_in[name]**2
                    n_ph  = kappa_c * n_in * (1 / (kappa**2/4 + (delta - chi/2)**2) 
                                            + 1 / (kappa**2/4 + (delta + chi/2)**2))
                    
                    gamma_d = n_ph * kappa * chi**2 / (kappa**2 + chi**2 + 4*delta**2)
                    Gamma_d[i] += gamma_d
                    
                    if verbose:
                        print('Coherent MID:', name, '>', 
                              self.modes_external_prop[j]['label'], '>',
                              self.modes_external_prop[i]['label'], '=', 
                              1 / gamma_d, 'us')
                    
            T_phi[name] = 1 / Gamma_d
            
        return T_phi
    
    def print_drive_results(self, variation):
        
        if len(self.hfss_vars_diff_idx) > 0:
            print('\n*** Different parameters')
            print(self.hfss_variables[self.hfss_vars_diff_idx][variation], '\n')
        
        print('\n*** Purcell effect')
        print(self.results[variation]['Purcell'])
        
        print('\n*** Thermal dephasing times (us)')
        print(self.results[variation]['T_MID_th'])
        
        print('\n*** Rabi frequencies of the pumped transitions (MHz)')
        print(self.results[variation]['Omega_R'])
        
        print('\n*** Pumps input power (nW)')
        print(self.results[variation]['Pin'])
        
        print('\n*** Pump induced dephasing times (us)')
        print(self.results[variation]['T_MID_coh'])
    
    def analyze_drives(self, variation, verbose=False, print_results=True):
        '''
        Args
            variation     : name of the variation to be analyzed
            verbose       : whether to plot extensive sub-results
            print_results : whether to plot analysis results
        '''
        if print_results:
            print('\n', '. '*40)
            print('Variation %s\n' % variation)
        else:
            print('%s, ' % variation, end='')
        
        result = self.results[variation]
        
        f     = result['f_1']
        Q     = result['Q_coupling']
        chi   = result['chi_O1'] * 2 * np.pi
        Lj    = result['Ljs']
        ZPF   = result['ZPF']
        phase = result['Drive_phase']
        
        Purcell     = self.calc_Purcell(f, Q)
        T_MID_th    = self.calc_MID_thermal(chi, f, Q, verbose)
        Omega_R     = self.calc_pumped_Rabi(chi, Lj)
        xsi_in, Pin = self.calc_input_power(f, Q, ZPF, phase, verbose)
        T_MID_coh   = self.calc_MID_coherent(f, chi, Q, xsi_in, verbose)
        
        self.results[variation]['Purcell']   = Purcell
        self.results[variation]['T_MID_th']  = T_MID_th
        self.results[variation]['Omega_R']   = Omega_R
        self.results[variation]['xsi_in']    = xsi_in
        self.results[variation]['Pin']       = Pin
        self.results[variation]['T_MID_coh'] = T_MID_coh
        
        self.results.save_to_npz()
        
        if print_results:
            self.print_drive_results(variation)
        
    def analyze_drives_all_variations(self, variations=None, **kwargs):
        '''
        See analyze_drives()
        '''
        if variations is None:
            variations = self.variations
            
        for variation in variations:
            self.analyze_drives(variation, **kwargs)
        

        
        

        
        
        
        
        